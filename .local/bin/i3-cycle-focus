#!/usr/bin/python3

from argparse import ArgumentParser
from collections import deque
import os
import selectors
import socket
import sys
import threading

import i3ipc


class LRUList(deque):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def update(self, val):
        if val in self:
            self.remove(val)
        self.appendleft(val)


class FocusWatcher:
    SOCKET_FILE = '/tmp/i3-cycle-focus'

    def __init__(self, ignore_float=False, max_history=16, delay=0.4):
        # options
        self.ignore_float = ignore_float
        self.delay = delay

        # ipc stuff
        self.i3 = i3ipc.Connection()
        self.i3.on('window::focus', self._on_window_focus)
        self.i3.on('window::new', self._on_window_new)
        self.i3.on('window::close', self._on_window_close)
        self.ipc_sock = self._prepare_ipc(self.SOCKET_FILE)

        # data
        self.window_index = 0
        self.window_list = LRUList(maxlen=max_history)
        self.focus_timer = None

    def _prepare_ipc(self, path):
        if os.path.exists(path):
            os.remove(path)
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(path)
        sock.listen()
        return sock

    def _update_windowlist(self, id_):
        self.window_list.update(id_)
        self.window_index = 0
        print(self.window_list)

    def _get_valid_windows(self):
        tree = self.i3.get_tree()
        # if args.active_workspace:
        #     return set(w.id for w in tree.find_focused().workspace().leaves())
        # elif args.visible_workspaces:
        #     ws_list = []
        #     w_set = set()
        #     for item in self.i3.get_outputs():
        #         ws_list.append(item["current_workspace"])
        #     for ws in tree.workspaces():
        #         if str(ws.num) in ws_list:
        #             for w in ws.leaves():
        #                 w_set.add(w.id)
        #     return w_set
        # else:
        return LRUList(w.id for w in tree.leaves())

    def _on_window_focus(self, i3conn, event):
        if self.ignore_float and (event.container.props.floating == "user_on" or
                                  event.container.props.floating == "auto_on"):
            return

        if self.delay > 0:
            if self.focus_timer is not None:
                self.focus_timer.cancel()

            self.focus_timer = threading.Timer(self.delay,
                                               self._update_windowlist,
                                               [event.container.props.id])
            self.focus_timer.start()
        else:
            self._update_windowlist(event.container.props.id)

    def _on_window_new(self, i3conn, event):
        new_id = event.container.props.id
        if new_id in self._get_valid_windows():
            self.window_list.append(new_id)

    def _on_window_close(self, i3conn, event):
        removed_id = event.container.props.id
        if removed_id in self.window_list:
            self.window_list.remove(removed_id)

    def _run_i3_watcher(self):
        self.i3.main()

    def _run_ipc(self):
        selector = selectors.DefaultSelector()

        def accept(sock):
            conn, addr = sock.accept()
            selector.register(conn, selectors.EVENT_READ, read)

        def read(conn):
            data = conn.recv(1024)
            if data == b'switch':
                while True:
                    self.window_index = (self.window_index + 1) % len(self.window_list)
                    window_id = self.window_list[self.window_index]
                    windows = self._get_valid_windows()
                    if window_id not in windows:
                        # Window does not exist anymore, delete and try again.
                        self.window_list.remove(window_id)
                    else:
                        # Success and get outta here.
                        self.i3.command(f'[con_id={window_id}] focus')
                        break
            elif not data:
                selector.unregister(conn)
                conn.close()

        selector.register(self.ipc_sock, selectors.EVENT_READ, accept)

        while True:
            for key, event in selector.select():
                callback = key.data
                callback(key.fileobj)

    def run(self):
        i3_watcher = threading.Thread(target=self._run_i3_watcher)
        ipc_server = threading.Thread(target=self._run_ipc)
        for t in (i3_watcher, ipc_server):
            t.start()


def parse_args():
    parser = ArgumentParser(prog='i3-cycle-focus.py',
        description="""
        Cycle backwards through the history of focused windows (aka Alt-Tab).
        This script should be launched from ~/.xsession or ~/.xinitrc.
        Use the `--history` option to set the maximum number of windows to be
        stored in the focus history (Default 16 windows).
        Use the `--delay` option to set the delay between focusing the
        selected window and updating the focus history (Default 2.0 seconds).
        Use a value of 0.0 seconds to toggle focus only between the current
        and the previously focused window. Use the `--ignore-floating` option
        to exclude all floating windows when cycling and updating the focus
        history. Use the `--visible-workspaces` option to include windows on
        visible workspaces only when cycling the focus history. Use the
        `--active-workspace` option to include windows on the active workspace
        only when cycling the focus history.

        To trigger focus switching, execute the script from a keybinding with
        the `--switch` option.""")
    parser.add_argument('--history', dest='history',
                        help='Maximum number of windows in the focus history',
                        type=int, default=16)
    parser.add_argument('--delay', dest='delay',
                        help='Delay before updating focus history',
                        type=float, default=0.2)
    parser.add_argument('--ignore-floating', dest='ignore_float',
                        action='store_true', help='Ignore floating windows '
                        'when cycling and updating the focus history')
    parser.add_argument('--visible-workspaces', dest='visible_workspaces',
                        action='store_true', help='Include windows on visible '
                        'workspaces only when cycling the focus history')
    parser.add_argument('--active-workspace', dest='active_workspace',
                        action='store_true', help='Include windows on the '
                        'active workspace only when cycling the focus history')
    parser.add_argument('-s', '--switch', dest='switch', action='store_true',
                        help='Switch to the previous window', default=False)
    return parser.parse_args()


def main():
    args = parse_args()

    if args.switch:
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        s.connect(FocusWatcher.SOCKET_FILE)
        s.send(b'switch')
        s.close()
        sys.exit(0)

    focus_watcher = FocusWatcher(ignore_float=args.ignore_float,
                                 delay=args.delay,
                                 max_history=args.history)
    focus_watcher.run()


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
